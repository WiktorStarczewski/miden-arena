const R={};async function k(){let e;return(!R||R)&&(e=await import("./Cargo-f372c2d2-f372c2d2-D-4vVzqw.js")),e}const y=Object.freeze({INIT:"init",INIT_MOCK:"initMock",CALL_METHOD:"callMethod",EXECUTE_CALLBACK:"executeCallback"}),m=Object.freeze({GET_KEY:"getKey",INSERT_KEY:"insertKey",SIGN:"sign"}),l=Object.freeze({CREATE_CLIENT:"createClient",NEW_WALLET:"newWallet",NEW_FAUCET:"newFaucet",EXECUTE_TRANSACTION:"executeTransaction",PROVE_TRANSACTION:"proveTransaction",SUBMIT_NEW_TRANSACTION:"submitNewTransaction",SUBMIT_NEW_TRANSACTION_MOCK:"submitNewTransactionMock",SUBMIT_NEW_TRANSACTION_WITH_PROVER:"submitNewTransactionWithProver",SUBMIT_NEW_TRANSACTION_WITH_PROVER_MOCK:"submitNewTransactionWithProverMock",SYNC_STATE:"syncState",SYNC_STATE_MOCK:"syncStateMock"});let _=null;const T=async()=>{if(_||(_=await k()),!_)throw new Error("Miden WASM bindings are unavailable in the worker environment.");return _},b=e=>{if(typeof e=="string")return e;try{return JSON.stringify(e)}catch{return String(e)}},g=e=>e instanceof Error?{name:e.name,message:e.message,stack:e.stack,cause:e.cause?g(e.cause):void 0,code:e.code}:typeof e=="object"&&e!==null?{name:e.name??"Error",message:e.message??b(e)}:{name:"Error",message:b(e)};let r=null,C=null,S=!1,z=[],M=!1,f=new Map;const A={getKey:async e=>new Promise((t,a)=>{const s=`${m.GET_KEY}-${Date.now()}-${Math.random()}`;f.set(s,{resolve:t,reject:a}),self.postMessage({action:y.EXECUTE_CALLBACK,callbackType:m.GET_KEY,args:[e],requestId:s})}),insertKey:async(e,t)=>new Promise((a,s)=>{const n=`${m.INSERT_KEY}-${Date.now()}-${Math.random()}`;f.set(n,{resolve:a,reject:s}),self.postMessage({action:y.EXECUTE_CALLBACK,callbackType:m.INSERT_KEY,args:[e,t],requestId:n})}),sign:async(e,t)=>new Promise((a,s)=>{const n=`${m.SIGN}-${Date.now()}-${Math.random()}`;f.set(n,{resolve:a,reject:s}),self.postMessage({action:y.EXECUTE_CALLBACK,callbackType:m.SIGN,args:[e,t],requestId:n})})},N={[l.NEW_WALLET]:async e=>{const t=await T(),[a,s,n,i]=e,o=t.AccountStorageMode.tryFromStr(a);return(await r.newWallet(o,s,n,i)).serialize().buffer},[l.NEW_FAUCET]:async e=>{const t=await T(),[a,s,n,i,o,c]=e,d=t.AccountStorageMode.tryFromStr(a),u=BigInt(o);return(await r.newFaucet(d,s,n,i,u,c)).serialize().buffer},[l.SYNC_STATE]:async()=>(await r.syncStateImpl()).serialize().buffer,[l.EXECUTE_TRANSACTION]:async e=>{const t=await T(),[a,s]=e,n=t.AccountId.fromHex(a),i=new Uint8Array(s),o=t.TransactionRequest.deserialize(i);return(await r.executeTransaction(n,o)).serialize().buffer},[l.PROVE_TRANSACTION]:async e=>{const t=await T(),[a,s]=e,n=new Uint8Array(a),i=t.TransactionResult.deserialize(n),o=s?t.TransactionProver.deserialize(s):void 0;return(await r.proveTransaction(i,o)).serialize().buffer},[l.SUBMIT_NEW_TRANSACTION]:async e=>{const t=await T(),[a,s]=e,n=t.AccountId.fromHex(a),i=new Uint8Array(s),o=t.TransactionRequest.deserialize(i),c=await r.executeTransaction(n,o),d=c.id().toHex(),u=await r.proveTransaction(c),w=await r.submitProvenTransaction(u,c),E=await r.applyTransaction(c,w);return{transactionId:d,submissionHeight:w,serializedTransactionResult:c.serialize().buffer,serializedTransactionUpdate:E.serialize().buffer}},[l.SUBMIT_NEW_TRANSACTION_WITH_PROVER]:async e=>{const t=await T(),[a,s,n]=e,i=t.AccountId.fromHex(a),o=new Uint8Array(s),c=t.TransactionRequest.deserialize(o),d=n?t.TransactionProver.deserialize(n):void 0,u=await r.executeTransaction(i,c),w=u.id().toHex(),E=await r.proveTransaction(u,d),p=await r.submitProvenTransaction(E,u),I=await r.applyTransaction(u,p);return{transactionId:w,submissionHeight:p,serializedTransactionResult:u.serialize().buffer,serializedTransactionUpdate:I.serialize().buffer}}};N[l.SYNC_STATE_MOCK]=async e=>{let[t,a]=e;return t=new Uint8Array(t),a=a?new Uint8Array(a):null,await r.createMockClient(C,t,a),await N[l.SYNC_STATE]()};N[l.SUBMIT_NEW_TRANSACTION_MOCK]=async e=>{const t=await T();let a=e.pop(),s=e.pop();s=new Uint8Array(s),a=a?new Uint8Array(a):null,r=new t.WebClient,await r.createMockClient(C,s,a);const n=await N[l.SUBMIT_NEW_TRANSACTION](e);return{transactionId:n.transactionId,submissionHeight:n.submissionHeight,serializedTransactionResult:n.serializedTransactionResult,serializedTransactionUpdate:n.serializedTransactionUpdate,serializedMockChain:r.serializeMockChain().buffer,serializedMockNoteTransportNode:r.serializeMockNoteTransportNode().buffer}};N[l.SUBMIT_NEW_TRANSACTION_WITH_PROVER_MOCK]=async e=>{const t=await T();let a=e.pop(),s=e.pop();s=new Uint8Array(s),a=a?new Uint8Array(a):null,r=new t.WebClient,await r.createMockClient(C,s,a);const n=await N[l.SUBMIT_NEW_TRANSACTION_WITH_PROVER](e);return{transactionId:n.transactionId,submissionHeight:n.submissionHeight,serializedTransactionResult:n.serializedTransactionResult,serializedTransactionUpdate:n.serializedTransactionUpdate,serializedMockChain:r.serializeMockChain().buffer,serializedMockNoteTransportNode:r.serializeMockNoteTransportNode().buffer}};async function U(e){const{action:t,args:a,methodName:s,requestId:n}=e.data;try{if(t===y.INIT){const[i,o,c,d,u,w,E,p]=a,I=await T();p&&I.setupLogging(p),r=new I.WebClient,u||w||E?await r.createClientWithExternalKeystore(i,o,c,d,u?A.getKey:void 0,w?A.insertKey:void 0,E?A.sign:void 0):await r.createClient(i,o,c,d),C=c,S=!0,self.postMessage({ready:!0});return}else if(t===y.INIT_MOCK){const[i,o]=a,c=await T();o&&c.setupLogging(o),r=new c.WebClient,await r.createMockClient(i),C=i,S=!0,self.postMessage({ready:!0});return}else if(t===y.CALL_METHOD){if(!S)throw new Error("Worker is not ready. Please initialize first.");if(!r)throw new Error("WebClient not initialized in worker.");const i=N[s];if(!i)throw new Error(`Unsupported method: ${s}`);const o=await i(a);self.postMessage({requestId:n,result:o,methodName:s});return}else throw new Error(`Unsupported action: ${t}`)}catch(i){const o=g(i);console.error("WORKER: Error occurred - %s",o.message,i),self.postMessage({requestId:n,error:o,methodName:s})}}async function h(){if(M||z.length===0)return;M=!0;const e=z.shift();try{await U(e)}finally{M=!1,h()}}self.onmessage=e=>{if(e.data.callbackRequestId&&f.has(e.data.callbackRequestId)){const{callbackRequestId:t,callbackResult:a,callbackError:s}=e.data,{resolve:n,reject:i}=f.get(t);f.delete(t),s?i(new Error(s)):n(a);return}z.push(e),h()};self.postMessage({loaded:!0});
